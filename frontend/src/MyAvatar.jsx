/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Enhanced for InterviewAce — accepts external speaking/emotion props
*/

import React, { useEffect, useRef, useMemo } from 'react'
import { useGraph, useFrame } from '@react-three/fiber'
import { useGLTF } from '@react-three/drei'
import { SkeletonUtils } from 'three-stdlib'
import * as THREE from 'three'

export function Model({ modelUrl = '/models/myAvatar.glb', externalSpeaking = false, externalEmotion = 0, ...props }) {
  const { scene } = useGLTF(modelUrl)
  const clone = useMemo(() => SkeletonUtils.clone(scene), [scene])
  const { nodes, materials } = useGraph(clone)

  // References
  const meshesRef = useRef([])
  const vowelsRef = useRef([])
  const headRef = useRef(null)

  // Setup & Discovery
  useEffect(() => {
    const foundMeshes = []

    Object.values(nodes).forEach((node) => {
      // Find Meshes for Morphs
      if (node.isMesh && node.morphTargetDictionary) {
        const keys = Object.keys(node.morphTargetDictionary)
        if (keys.includes("Fcl_MTH_A") || keys.includes("Mouth_A")) {
          foundMeshes.push(node)
        }
      }

      // Pose Fix
      if (node.isBone || node.type === "Bone") {
        const name = node.name.toLowerCase()
        const isLeft = name.includes("left") || name.includes("_l_") || name.startsWith("l_")
        const isRight = name.includes("right") || name.includes("_r_") || name.startsWith("r_")
        const isArm = name.includes("arm") && !name.includes("fore") && !name.includes("hand") && !name.includes("clavicle") && !name.includes("shoulder")
        const isLeg = (name.includes("leg") || name.includes("thigh")) && !name.includes("lower") && !name.includes("calf")
        const isHand = name.includes("hand") || name.includes("wrist")

        if (isArm) {
          if (isLeft) { node.rotation.z = -Math.PI / 3.2; node.rotation.y = -Math.PI / 12; node.rotation.x = Math.PI / 16 }
          if (isRight) { node.rotation.z = Math.PI / 3.2; node.rotation.y = Math.PI / 12; node.rotation.x = Math.PI / 16 }
        }
        if (isLeg) {
          if (isLeft) node.rotation.z = -Math.PI / 36
          if (isRight) node.rotation.z = Math.PI / 36
        }
        if (isHand) {
          if (isLeft) node.rotation.x = Math.PI / 12
          if (isRight) node.rotation.x = Math.PI / 12
        }

        const isHead = name.includes("head") || name.includes("neck")
        if (isHead && !headRef.current) {
          headRef.current = node
        }
      }
    })

    if (foundMeshes.length > 0) {
      meshesRef.current = foundMeshes
      const dict = foundMeshes[0].morphTargetDictionary
      const getIdx = (candidates) => {
        for (let c of candidates) if (dict[c] !== undefined) return dict[c]
        return -1
      }

      const newVowels = [
        getIdx(["Fcl_MTH_A", "Mouth_A", "A"]),
        getIdx(["Fcl_MTH_I", "Mouth_I", "I"]),
        getIdx(["Fcl_MTH_U", "Mouth_U", "U"]),
        getIdx(["Fcl_MTH_E", "Mouth_E", "E"]),
        getIdx(["Fcl_MTH_O", "Mouth_O", "O"])
      ].filter(idx => idx !== -1)

      vowelsRef.current = newVowels.length > 0 ? newVowels : [39, 40, 41, 42, 43]
    }
  }, [nodes])

  // Animation Loop — uses external props
  useFrame((state) => {
    if (meshesRef.current.length === 0) return
    const t = state.clock.elapsedTime

    // Emotion weights
    const emotionWeights = {}
    for (let i = 0; i <= 5; i++) {
      emotionWeights[i] = (i === externalEmotion) ? 1 : 0
    }

    // Speech mouth opening
    let open = 0
    if (externalSpeaking) {
      open = (Math.sin(t * 30) + 1) * 0.5 + Math.random() * 0.3
      open = Math.min(open, 1.0)
    }

    // Apply to ALL meshes
    meshesRef.current.forEach(mesh => {
      if (!mesh.morphTargetInfluences) return

      // Emotions
      for (let i = 0; i <= 5; i++) {
        mesh.morphTargetInfluences[i] = THREE.MathUtils.lerp(mesh.morphTargetInfluences[i], emotionWeights[i], 0.1)
      }

      // Lip Sync
      if (externalSpeaking) {
        vowelsRef.current.forEach(idx => {
          if (idx < mesh.morphTargetInfluences.length) {
            mesh.morphTargetInfluences[idx] = THREE.MathUtils.lerp(mesh.morphTargetInfluences[idx], open, 0.4)
          }
        })
      } else {
        vowelsRef.current.forEach(idx => {
          if (idx < mesh.morphTargetInfluences.length) {
            mesh.morphTargetInfluences[idx] = THREE.MathUtils.lerp(mesh.morphTargetInfluences[idx], 0, 0.1)
          }
        })
      }
    })

    // Subtle idle head movement
    if (headRef.current) {
      const nodAmount = Math.sin(t * 0.8) * 0.08
      const tiltAmount = Math.sin(t * 0.5) * 0.04
      headRef.current.rotation.x = THREE.MathUtils.lerp(headRef.current.rotation.x, nodAmount, 0.05)
      headRef.current.rotation.z = THREE.MathUtils.lerp(headRef.current.rotation.z, tiltAmount, 0.05)
    }
  })

  return (
    <group {...props} dispose={null}>
      <primitive object={clone} />
    </group>
  )
}
